# -*- coding: utf-8 -*-
""">>Monte Carlo<<.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aDcxa7e9-6RU_i1vmRBzXti4ren_MDCQ
"""



!pip install -q py3Dmol

!pip install -q ase openpyxl tqdm

# ----------------------------------------
# 📌 ONE-TIME USER INPUT BLOCK
# ----------------------------------------
user_input = {
    'element_A': 'Pt',
    'element_B': 'Ru',
    'composition_A': 0.5,
    'temperature': 250.0,
    'n_steps': 10000,
    'save_interval': 1000,
    'capture_frames': True,
    'frame_interval': 1000,
    'layers': (7, 7, 7),
    'surfaces': [(1, 1, 1), (1, 1, 1), (1, 1, 0)],
    'lattice_type': 'fcc',  # Choose 'fcc', 'bcc', or 'hcp'
    'coefficients': {
        'xA-A': -0.022078,
        'xB-B': -0.150000,
        'xA-B': -0.109575,
        'xA-S': -0.250717,
        'xB-S': -0.300000,
        'xA-A-out': 0.184150,
        'xB-B-out': 0.332228,
        'xA-B-out': 0.051042
    }
}

import random, math, time, os
import numpy as np
from ase.io import write, read
from ase.neighborlist import build_neighbor_list
from openpyxl import Workbook
from tqdm import tqdm

# ASE cluster imports for lattices
from ase.cluster import FaceCenteredCubic, BodyCenteredCubic, HexagonalClosedPacked

# --- Extract user inputs ---
A = user_input['element_A']
B = user_input['element_B']
composition_A = user_input['composition_A']
T = user_input['temperature']
N_STEPS = user_input['n_steps']
SAVE_INTERVAL = user_input['save_interval']
LAYERS = user_input['layers']
SURFACES = user_input['surfaces']
COEFFS = user_input['coefficients']
LATTICE_TYPE = user_input.get('lattice_type', 'fcc').lower()  # default fcc
BOLTZMANN_K = 8.617333262e-5
BULK_COORD = 12

# --- Map lattice type to ASE cluster builder ---
lattice_map = {
    'fcc': FaceCenteredCubic,
    'bcc': BodyCenteredCubic,
    'hcp': HexagonalClosedPacked
}

ClusterBuilder = lattice_map.get(LATTICE_TYPE)
if ClusterBuilder is None:
    raise ValueError(f"Unsupported lattice type '{LATTICE_TYPE}'. Choose from 'fcc', 'bcc', or 'hcp'.")

# --- Generate Nanoparticle ---
particle = ClusterBuilder(A, surfaces=SURFACES, layers=LAYERS)
n_atoms = len(particle)
n_A = int(n_atoms * composition_A)
indices_A = random.sample(range(n_atoms), n_A)
for i in range(n_atoms):
    particle[i].symbol = A if i in indices_A else B

xyz_file = f"{A}{B}_initial_{n_atoms}.xyz"
write(xyz_file, particle)
print(f"✅ Structure generated with {n_atoms} atoms in {LATTICE_TYPE.upper()} lattice. Saved as: {xyz_file}")

# --- Helper Functions ---
def symbol_type(sym):
    return 'A' if sym == A else 'B'

def calculate_energy(p, coeffs):
    nl = build_neighbor_list(p, bothways=True, self_interaction=False)
    count = {k: 0 for k in coeffs}
    for i in range(len(p)):
        t_i = symbol_type(p[i].symbol)
        neighbors = nl.get_neighbors(i)[0]
        if len(neighbors) < BULK_COORD:
            count[f'x{t_i}-S'] += 1
        for j in neighbors:
            if i < j:
                t_j = symbol_type(p[j].symbol)
                if t_i == t_j:
                    count[f'x{t_i}-{t_j}'] += 1
                else:
                    count['xA-B'] += 1
    return sum(coeffs[k] * count[k] for k in count)

def count_surface(p):
    nl = build_neighbor_list(p, bothways=True, self_interaction=False)
    total_A, surf, surf_A = 0, 0, 0
    for i in range(len(p)):
        neighbors = nl.get_neighbors(i)[0]
        t = symbol_type(p[i].symbol)
        if t == 'A': total_A += 1
        if len(neighbors) < BULK_COORD:
            surf += 1
            if t == 'A': surf_A += 1
    ratio = surf_A / surf if surf else 0
    return total_A, surf, surf_A, ratio

# Save initial state for comparison
initial_surface_data = count_surface(particle)
initial_xyz = f"{A}{B}_initial_{n_atoms}.xyz"
write(initial_xyz, particle)
print(f"🧬 Initial structure saved for reference: {initial_xyz}")

from ase.io import write
import os

# --- Parameters ---
SAVE_INTERVAL = 200               # Interval for logging data
SNAPSHOT_INTERVAL = 500         # Interval for saving .xyz snapshots
os.makedirs("trajectory", exist_ok=True)

# --- Monte Carlo Simulation ---
energy = calculate_energy(particle, COEFFS)
log = []
start_time = time.time()
print("\n🔁 Starting Monte Carlo Simulation...\n")

for step in tqdm(range(1, N_STEPS + 1)):
    i = random.randint(0, n_atoms - 1)
    neighbors = build_neighbor_list(particle).get_neighbors(i)[0]
    if len(neighbors) == 0: continue
    j = random.choice(neighbors)
    if particle[i].symbol == particle[j].symbol: continue

    trial = particle.copy()
    trial[i].symbol, trial[j].symbol = trial[j].symbol, trial[i].symbol
    dE = calculate_energy(trial, COEFFS) - energy

    if dE < 0 or random.random() < math.exp(-dE / (BOLTZMANN_K * T)):
        particle = trial
        energy += dE

    # 🧾 Log data
    if step % SAVE_INTERVAL == 0:
        total_A, surf, surf_A, ratio = count_surface(particle)
        log.append({
            'Step': step,
            'Energy (eV)': energy,
            f'Total {A}': total_A,
            'Surface Atoms': surf,
            f'{A} on Surface': surf_A,
            f'Surface {A} Ratio': ratio
        })
        print(f"📘 Step {step} | Energy: {energy:.3f} eV | Surface {A} Ratio: {ratio:.4f}")

    # 📸 Save snapshot
    if step % SNAPSHOT_INTERVAL == 0:
        snapshot_file = f"trajectory/step_{step:05d}.xyz"
        write(snapshot_file, particle)
        print(f"📸 Saved snapshot at step {step}")

!pip install ase imageio

# --- Save Final Structure and Excel Log ---
final_xyz = f"final_{A}{B}_{n_atoms}.xyz"
write(final_xyz, particle)
print(f"\n✅ Final structure saved as: {final_xyz}")
print(f"⏱️ Total simulation time: {time.time() - start_time:.2f} seconds")

# Excel log export
xlsx_file = f"MMC_{A}{B}_log.xlsx"
wb = Workbook()
ws = wb.active
ws.title = "Simulation Log"

params = [
    ("Element A", A), ("Element B", B), ("Composition A", composition_A),
    ("Temperature (K)", T), ("MC Steps", N_STEPS),
    ("Save Interval", SAVE_INTERVAL), ("Total Atoms", n_atoms)
]
for i, (k, v) in enumerate(params, 1):
    ws.cell(row=i, column=1, value=k)
    ws.cell(row=i, column=2, value=v)

header_row = len(params) + 2
headers = list(log[0].keys())
for j, h in enumerate(headers, 1):
    ws.cell(row=header_row, column=j, value=h)

for i, entry in enumerate(log, header_row + 1):
    for j, h in enumerate(headers, 1):
        ws.cell(row=i, column=j, value=entry[h])

wb.save(xlsx_file)
print(f"📁 Log file saved: {xlsx_file}")

import matplotlib.pyplot as plt

steps = [entry['Step'] for entry in log]
energy = [entry['Energy (eV)'] for entry in log]
surface_ratio = [entry[f'Surface {A} Ratio'] for entry in log]

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(steps, energy, label='Energy (eV)', color='blue')
plt.xlabel('MC Step'); plt.ylabel('Energy (eV)')
plt.title('Energy vs. Step'); plt.grid(True)

plt.subplot(1, 2, 2)
plt.plot(steps, surface_ratio, label=f'Surface {A} Ratio', color='green')
plt.xlabel('MC Step'); plt.ylabel(f'{A} Surface Atom Ratio')
plt.title(f'Surface {A}% vs. Step'); plt.grid(True)

plt.tight_layout(); plt.show()

# --- ✅ Final Validation & Sanity Check ---

import math
import numpy as np

print("\n🔍 Running validation checks...")
errors = 0

# 1. Atom count check
if len(particle) != n_atoms:
    print(f"❌ Atom count mismatch: expected {n_atoms}, found {len(particle)}")
    errors += 1
else:
    print(f"✅ Atom count is correct: {n_atoms}")

# 2. Final energy NaN check (use the last logged energy)
final_energy = log[-1]['Energy (eV)']
if isinstance(final_energy, (float, int)):
    if math.isnan(final_energy):
        print("❌ Final energy is NaN.")
        errors += 1
    else:
        print(f"✅ Final energy is valid: {final_energy:.4f} eV")
else:
    print("❌ Final energy is not a scalar.")
    errors += 1

# 3. Surface atom sanity
_, surf_atoms, surf_A, final_ratio = count_surface(particle)
if surf_atoms == 0:
    print("❌ No surface atoms detected.")
    errors += 1
else:
    print(f"✅ Surface atoms present: {surf_atoms} total, {surf_A} are {A} atoms.")
    print(f"➡️ Final Surface {A}%: {final_ratio:.4f}")

# 4. Surface ratio non-trivial
if final_ratio == 0 or final_ratio == 1:
    print("⚠️ Surface composition is fully segregated. May or may not be physical.")
else:
    print("✅ Surface composition is mixed.")

# Final validation result
if errors == 0:
    print("\n✅ Validation PASSED. System is physically consistent.")
else:
    print(f"\n⚠️ Validation completed with {errors} issue(s). Check configuration.")

# --- 📊 Compare Before vs After Surface Ratios ---
init_total, init_surf, init_surf_A, init_ratio = initial_surface_data
final_total, final_surf, final_surf_A, final_ratio = count_surface(particle)

print("\n🔁 Surface Comparison: BEFORE vs AFTER")
print(f"  Surface atoms:         {init_surf:>4} ➡️ {final_surf:>4}")
print(f"  {A} on surface:        {init_surf_A:>4} ➡️ {final_surf_A:>4}")
print(f"  Surface {A} Ratio:   {init_ratio:.4f} ➡️ {final_ratio:.4f}")

delta = final_ratio - init_ratio
change_str = f"🔼 Increased by {delta:.4f}" if delta > 0 else f"🔽 Decreased by {abs(delta):.4f}" if delta < 0 else "No change"
print(f"  ➡️ Change: {change_str}")

!pip install -q py3Dmol

def view_xyz_colored(xyz_file, atom_A, atom_B, radius=1.5):
    import py3Dmol
    from IPython.display import display

    with open(xyz_file) as f:
        xyz_data = f.read()

    view = py3Dmol.view(width=500, height=500)
    view.addModel(xyz_data, 'xyz')

    # Style atoms by element symbol from parameters
    view.setStyle(
        { "elem": atom_A },
        { "sphere": { "color": "gold", "radius": radius } }
    )
    view.setStyle(
        { "elem": atom_B },
        { "sphere": { "color": "green", "radius": radius } }
    )

    view.setBackgroundColor("white")
    view.zoomTo()
    return view

print("🧬 Initial Structure")
view_xyz_colored(initial_xyz, atom_A=A, atom_B=B).show()

print("🧬 Final Structure")
view_xyz_colored(final_xyz, atom_A=A, atom_B=B).show()

import os
import imageio.v2 as imageio  # use v2 to suppress future deprecation warnings
import numpy as np
import matplotlib.pyplot as plt
from ase.io import read
from ase.visualize.plot import plot_atoms
from ase.data.colors import jmol_colors
import openpyxl

# --- User Parameters ---
trajectory_folder = "trajectory"  # Folder containing your .xyz snapshots
xlsx_file = "MMC_PtRu_log.xlsx"   # Your MMC simulation Excel log filename
fps = 1                          # Video frames per second
output_movie = "3D_MC_Enhanced_Movie_With_Inset.mp4"

# Custom color map for atoms
symbol_to_color = {
    'Pt': 'silver',
    'Ru': 'royalblue',
    'Fe': '#d62728',
    'Sn': '#2ca02c',
    'Pb': '#ff7f0e',
    'Co': '#9467bd',
    'Au': '#e6c200',
    'Cu': '#17becf',
}

# --- Load MMC Excel Log ---
print(f"📥 Loading Excel log: {xlsx_file}")
wb = openpyxl.load_workbook(xlsx_file, data_only=True)
ws = wb.active  # Adjust if your log is on a different sheet by name

# Find header row (skip param rows) - here assumed after 8 rows of params + 1 blank line
header_row = 10  # Change this if your excel layout differs
headers = [cell.value for cell in ws[header_row]]

# Find required columns
step_col = headers.index('Step') + 1
energy_col = headers.index('Energy (eV)') + 1
surface_ratio_col = None
for key in ['Surface Ratio', 'Surface Atoms Ratio', 'Surface A Ratio', 'Surface Ratio (A)']:
    if key in headers:
        surface_ratio_col = headers.index(key) + 1
        break

steps = []
energies = []
surface_ratios = []

for row in ws.iter_rows(min_row=header_row+1, max_row=ws.max_row):
    steps.append(row[step_col-1].value)
    energies.append(row[energy_col-1].value)
    if surface_ratio_col:
        surface_ratios.append(row[surface_ratio_col-1].value)
    else:
        surface_ratios.append(None)

print(f"Loaded {len(steps)} log entries from Excel.")

# --- Load XYZ Snapshots ---
xyz_files = sorted([f for f in os.listdir(trajectory_folder) if f.endswith(".xyz")])
print(f"📦 Found {len(xyz_files)} snapshots in '{trajectory_folder}'.")

images = []

for step_idx, xyz_file in enumerate(xyz_files, 1):
    atoms = read(os.path.join(trajectory_folder, xyz_file))
    label = xyz_file.replace(".xyz", "")  # e.g. 'step_01500'

    # Parse numeric step number from filename (assumes format like step_01500)
    try:
        current_step = int(''.join(filter(str.isdigit, label)))
    except:
        current_step = step_idx  # fallback if parsing fails

    # Assign atom colors and count present elements
    colors = {}
    element_counts = {}
    for i, atom in enumerate(atoms):
        symbol = atom.symbol
        colors[i] = symbol_to_color.get(symbol, tuple(jmol_colors[atom.number]))
        element_counts[symbol] = element_counts.get(symbol, 0) + 1

    print(f"🎬 Rendering {label} (Step {current_step})...")

    # Setup plot
    fig, ax = plt.subplots(figsize=(7, 7), dpi=300)
    fig.patch.set_facecolor('#f0f0f0')
    ax.set_facecolor('#f0f0f0')

    plot_atoms(
        atoms, ax,
        radii=0.6,
        colors=colors,
        rotation=('30x,30y,0z'),
        show_unit_cell=0
    )

    # Frame label bottom-right
    fig.text(
        0.95, 0.05, label,
        ha='right', va='bottom',
        fontsize=11, color='black',
        bbox=dict(facecolor='white', edgecolor='gray', boxstyle='round,pad=0.3')
    )

    # Legend top-left with counts, e.g. ● Pt (58)
    x0, y0 = 0.05, 0.95
    dy = 0.035
    for idx, symbol in enumerate(sorted(element_counts.keys())):
        count = element_counts[symbol]
        fig.text(
            x0, y0 - idx * dy,
            f"● {symbol} ({count})",
            fontsize=10,
            ha='left', va='top',
            color=symbol_to_color.get(symbol, 'gray'),
            fontweight='bold'
        )

    # Inset plot: energy and surface ratio up to current step
    inset_ax = fig.add_axes([0.6, 0.75, 0.35, 0.2])  # x, y, width, height (figure coords)
    # Find closest log index for current_step
    idx = min(range(len(steps)), key=lambda i: abs(steps[i] - current_step))

    inset_ax.plot(steps[:idx + 1], energies[:idx + 1], color='blue', label='Energy (eV)')
    if surface_ratio_col:
        inset_ax.plot(steps[:idx + 1], surface_ratios[:idx + 1], color='orange', label='Surface Ratio')

    inset_ax.set_xlabel('Step', fontsize=8)
    inset_ax.set_ylabel('Value', fontsize=8)
    inset_ax.tick_params(axis='both', which='major', labelsize=7)
    inset_ax.legend(fontsize=7)
    inset_ax.grid(True, linestyle='--', alpha=0.5)

    ax.axis('off')

    # Save frame image
    tmp_png = f"/tmp/{xyz_file}.png"
    fig.savefig(tmp_png)
    plt.close(fig)

    images.append(imageio.imread(tmp_png))

# --- Compile video ---
print("🎞️ Compiling final video...")
imageio.mimsave(output_movie, images, fps=fps)
print(f"✅ Final movie saved as: {output_movie}")

from google.colab import files
files.download("nanoparticle_evolution.mp4")